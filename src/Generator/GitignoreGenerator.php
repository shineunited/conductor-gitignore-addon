<?php

/**
 * This file is part of Conductor Gitignore Addon.
 *
 * (c) Shine United LLC
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

namespace ShineUnited\Conductor\Addon\Gitignore\Generator;

use ShineUnited\Conductor\Addon\Gitignore\Blueprint\GitignoreBlueprintInterface;
use ShineUnited\Conductor\Addon\Gitignore\Capability\GitignoreProvider as GitignoreProviderCapability;
use ShineUnited\Conductor\Addon\Gitignore\Pattern\Ruleset;
use ShineUnited\Conductor\Addon\Gitignore\Pattern\Rule;
use ShineUnited\Conductor\Addon\Gitignore\Blueprint\GitignoreBlueprint;
use ShineUnited\Conductor\Filesystem\File;
use ShineUnited\Conductor\Filesystem\Blueprint\BlueprintInterface;
use ShineUnited\Conductor\Filesystem\Generator\GeneratorInterface;
use ShineUnited\Conductor\Configuration\Configuration;
use Composer\Repository\RepositoryManager;
use Composer\Installer\InstallationManager;
use Composer\Plugin\PluginManager;
use Composer\Plugin\Capable;
use Symfony\Component\Filesystem\Path;

/**
 * Gitignore Generator
 */
class GitignoreGenerator implements GeneratorInterface {
	private const START = 'AUTOGENERATED - START (DO NOT EDIT BELOW THIS LINE)';
	private const END = 'AUTOGENERATED - END (YOU MAY RESUME EDITING)';

	/**
	 * {@inheritDoc}
	 */
	public function handlesBlueprint(BlueprintInterface $blueprint): bool {
		if ($blueprint instanceof GitignoreBlueprintInterface) {
			return true;
		}

		return false;
	}

	/**
	 * {@inheritDoc}
	 *
	 * @throws \Exception If not instance of GitignoreBlueprint
	 */
	public function generateContents(BlueprintInterface $blueprint, File $file, Configuration $config): string {
		if (!$blueprint instanceof GitignoreBlueprintInterface) {
			throw new \Exception('Invalid ' . GitignoreBlueprint::class);
		}

		$rulesets = [];

		$rulesets['global'] = new Ruleset('Global');

		if ($config['gitignore.ignore-lockfile']) {
			$rulesets['global']->addRule(new Rule('{$working-dir}/composer.lock'));
		}

		if ($config['gitignore.ignore-pharfile']) {
			$rulesets['global']->addRule(new Rule('{$working-dir}/composer.phar'));
		}

		if ($config['gitignore.ignore-vendordir']) {
			$rulesets['global']->addRule(new Rule('{$vendor-dir}'));
		}

		if ($config['gitignore.ignore-packages']) {
			$packageRulesets = $config->processCallableValue(function (RepositoryManager $rm, InstallationManager $im) use ($config) {
				$rulesets = [];

				$localRepository = $rm->getLocalRepository();
				foreach ($localRepository->getPackages() as $package) {
					$installPath = $im->getInstallPath($package);

					if (is_null($installPath)) {
						continue;
					}

					if (strlen(trim($installPath)) == 0) {
						continue;
					}

					$installPath = Path::canonicalize($installPath);
					if (!Path::isAbsolute($installPath)) {
						$installPath = Path::makeAbsolute($installPath, $config['working-dir']);
					}

					if (Path::isBasePath($config['vendor-dir'], $installPath)) {
						// ignore, already excluded by vendor exclusions
						continue;
					}

					$packageType = $package->getType();
					if (!isset($rulesets[$packageType])) {
						$rulesets[$packageType] = new Ruleset('Package Type: ' . $packageType);
					}

					$rulesets[$packageType]->addRule(new Rule($installPath));
				}

				ksort($rulesets);

				return array_values($rulesets);
			});

			$rulesets = array_merge($rulesets, $packageRulesets);
		}

		$pluginRulesets = $config->processCallableValue(function (PluginManager $pluginManager) use ($config) {
			$rulesets = [];

			foreach ($pluginManager->getPlugins() as $plugin) {
				if (!$plugin instanceof Capable) {
					continue;
				}

				$gitignoreProvider = $pluginManager->getPluginCapability($plugin, GitignoreProviderCapability::class, [
					'config' => $config
				]);

				if (is_null($gitignoreProvider)) {
					continue;
				}

				$ruleset = new Ruleset('Plugin: ' . $plugin::class);
				foreach ($gitignoreProvider->getGitignores() as $rule) {
					$ruleset->addRule($rule);
				}
				$rulesets[] = $ruleset;
			}

			return array_values($rulesets);
		});

		$rulesets = array_merge($rulesets, $pluginRulesets);


		// write gitignore file
		$startComment = str_pad('# ' . self::START . ' #', 80, '#', STR_PAD_BOTH);
		$endComment = str_pad('# ' . self::END . ' #', 80, '#', STR_PAD_BOTH);

		$autogenerated = [];
		$autogenerated[] = $startComment;
		$autogenerated[] = '';
		foreach ($rulesets as $ruleset) {
			if (!$ruleset->hasRules()) {
				continue;
			}

			$autogenerated[] = '# ' . $ruleset->getName();
			foreach ($ruleset->getRules() as $rule) {
				$rulePath = $config->processValue($rule->getPath());
				$autogenerated[] = $this->fixRulePath($rulePath, $file);
				foreach ($rule->getExcludes() as $exclude) {
					$excludePath = $config->processValue($exclude->getPath());
					$autogenerated[] = '!' . $this->fixRulePath($excludePath, $file);
				}
			}
			$autogenerated[] = '';
		}
		$autogenerated[] = $endComment;

		$currentContents = $file->getContents();
		$lines = explode(PHP_EOL, $currentContents);

		$startOffset = array_search($startComment, $lines, true);
		if ($startOffset === false) {
			// not currently found, add to end
			$lines = array_values(array_merge($lines, [''], $autogenerated));
		} else {
			$endOffset = array_search($endComment, $lines, true);
			if ($endOffset === false) {
				// doesn't exist, take everything after
				$endOffset = count($lines) - 1;
			}

			$length = $endOffset - $startOffset + 1;
			if ($length < 1) {
				// end is before start, WTF?
				$length = 1;
			}

			array_splice($lines, $startOffset, $length, $autogenerated);
		}

		return rtrim(implode(PHP_EOL, $lines)) . PHP_EOL;
	}

	private function fixRulePath(string $rulePath, File $file): string {
		$rulePath = Path::canonicalize($rulePath);
		if (!Path::isAbsolute($rulePath)) {
			$rulePath = Path::makeAbsolute($rulePath, getcwd());
		}

		return Path::makeRelative($rulePath, $file->getDirectory());
	}
}
